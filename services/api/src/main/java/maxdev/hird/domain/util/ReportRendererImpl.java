package maxdev.hird.domain.util;

import com.lowagie.text.*;
import com.lowagie.text.pdf.*;
import maxdev.hird.model.AnomalySignal;
import maxdev.hird.model.ModelPrediction;
import maxdev.hird.model.RiskGauge;
import org.jfree.chart.ChartUtils;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYDifferenceRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.springframework.stereotype.Component;

import java.awt.Color;
import java.io.ByteArrayOutputStream;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.util.List;


@Component
public class ReportRendererImpl implements ReportRenderer {

    private static final int CHART_WIDTH_PIXELS = 600;
    private static final int CHART_HEIGHT_PIXELS = 300;

    private static final int FORECAST_IMAGE_MAX_WIDTH_POINTS = 400;
    private static final int FORECAST_IMAGE_MAX_HEIGHT_POINTS = 200;

    private static final float TABLE_GRID_WIDTH_POINTS = 0.5f;

    private static final int RISK_TABLE_WIDTH_PERCENT = 60;
    private static final int ANOMALY_TABLE_WIDTH_PERCENT = 70;

    private static final Color FORECAST_LINE_COLOR = new Color(0, 0, 255);
    private static final Color FORECAST_BAND_COLOR = new Color(0, 0, 255, 51);

    private static final Color RISK_HEADER_COLOR = Color.BLACK;
    private static final Color ANOMALY_HEADER_COLOR = new Color(139, 0, 0);
    private static final Color TABLE_BODY_COLOR = new Color(245, 245, 245);
    private static final Color TABLE_GRID_COLOR = Color.GRAY;

    @Override
    public byte[] render(
            String city,
            List<ModelPrediction> forecastRows,
            List<RiskGauge> riskRows,
            List<AnomalySignal> anomalyRows
    ) {
        return generatePdf(document -> {
            writeTitle(document, city);
            writeForecastSection(document, city, forecastRows);
            writeRiskSection(document, riskRows);
            writeAnomalySection(document, anomalyRows);
            writeFooter(document);
        });
    }

    private interface DocumentWriter {
        void write(Document document) throws Exception;
    }

    private byte[] generatePdf(DocumentWriter writer) {
        try (ByteArrayOutputStream pdfBytes = new ByteArrayOutputStream()) {
            Document document = new Document(PageSize.LETTER);
            PdfWriter.getInstance(document, pdfBytes);

            document.open();
            writer.write(document);
            document.close();

            return pdfBytes.toByteArray();
        } catch (Exception e) {
            throw new RuntimeException("Failed to render PDF report", e);
        }
    }

    private void writeTitle(Document document, String city) throws Exception {
        document.add(new Paragraph(
                "Housing Insights Report — " + uppercaseFirstChar(city),
                font(FontFactory.HELVETICA_BOLD, 18, Color.BLACK)
        ));
        writeSectionSpacing(document);
    }

    private String uppercaseFirstChar(String city){
        return city.substring(0, 1).toUpperCase() + city.substring(1).toLowerCase();
    }

    private void writeForecastSection(Document document, String city, List<ModelPrediction> forecastRows) throws Exception {
        if (forecastRows.isEmpty()) return;

        document.add(heading("Forecast"));
        document.add(newLine());

        Image forecastImage = Image.getInstance(renderForecastChartPng(uppercaseFirstChar(city), forecastRows));
        forecastImage.scaleToFit(FORECAST_IMAGE_MAX_WIDTH_POINTS, FORECAST_IMAGE_MAX_HEIGHT_POINTS);
        forecastImage.setAlignment(Image.ALIGN_CENTER);

        document.add(forecastImage);
        writeSectionSpacing(document);
    }

    private void writeRiskSection(Document document, List<RiskGauge> riskRows) throws Exception {
        if (riskRows.isEmpty()) return;

        document.add(heading("Risk Indices"));
        document.add(newLine());

        PdfPTable riskTable = buildRiskTable(riskRows);
        document.add(riskTable);

        writeSectionSpacing(document);
    }

    private void writeAnomalySection(Document document, List<AnomalySignal> anomalyRows) throws Exception {
        if (anomalyRows.isEmpty()) return;

        document.add(heading("Recent Anomalies"));
        document.add(newLine());

        PdfPTable anomalyTable = buildAnomalyTable(anomalyRows);
        document.add(anomalyTable);

        writeSectionSpacing(document);
    }

    private void writeFooter(Document document) throws Exception {
        document.add(newLine());
        document.add(new Paragraph(
                "Generated by Housing Insights & Risk Dashboard — © 2025",
                font(FontFactory.HELVETICA, 10, Color.BLACK)
        ));
    }

    private void writeSectionSpacing(Document document) throws Exception {
        document.add(newLine());
        document.add(newLine());
    }

    private Paragraph heading(String text) {
        return new Paragraph(text, font(FontFactory.HELVETICA_BOLD, 13, Color.BLACK));
    }

    private Chunk newLine() {
        return Chunk.NEWLINE;
    }

    private Font font(String name, int size, Color color) {
        return FontFactory.getFont(name, size, color);
    }

    private PdfPTable buildRiskTable(List<RiskGauge> riskRows) throws Exception {
        PdfPTable table = createTable(2, new float[]{200f, 150f}, RISK_TABLE_WIDTH_PERCENT);
        addRiskTableHeader(table);
        addRiskTableRows(table, riskRows);
        return table;
    }

    private void addRiskTableHeader(PdfPTable table) {
        table.addCell(headerCell("Risk Type", RISK_HEADER_COLOR));
        table.addCell(headerCell("Value", RISK_HEADER_COLOR));
    }

    private void addRiskTableRows(PdfPTable table, List<RiskGauge> riskRows) {
        for (RiskGauge riskGauge : riskRows) {
            table.addCell(bodyCell(riskGauge.getRiskType()));
            table.addCell(bodyCell(String.format("%.2f", riskGauge.getRiskValue())));
        }
    }

    private PdfPTable buildAnomalyTable(List<AnomalySignal> anomalyRows) throws Exception {
        PdfPTable table = createTable(3, new float[]{120f, 150f, 100f}, ANOMALY_TABLE_WIDTH_PERCENT);
        addAnomalyTableHeader(table);
        addAnomalyTableRows(table, anomalyRows);
        return table;
    }

    private void addAnomalyTableHeader(PdfPTable table) {
        table.addCell(headerCell("Date", ANOMALY_HEADER_COLOR));
        table.addCell(headerCell("Target", ANOMALY_HEADER_COLOR));
        table.addCell(headerCell("Score", ANOMALY_HEADER_COLOR));
    }

    private void addAnomalyTableRows(PdfPTable table, List<AnomalySignal> anomalyRows) {
        for (AnomalySignal anomalySignal : anomalyRows) {
            table.addCell(bodyCell(anomalySignal.getDetectDate().toString()));
            table.addCell(bodyCell(anomalySignal.getTarget()));
            table.addCell(bodyCell(String.format("%.2f", anomalySignal.getAnomalyScore())));
        }
    }

    private PdfPTable createTable(int columns, float[] columnWidths, int widthPercent) throws Exception {
        PdfPTable table = new PdfPTable(columns);
        table.setWidths(columnWidths);
        table.setWidthPercentage(widthPercent);
        return table;
    }

    private PdfPCell headerCell(String text, Color headerColor) {
        PdfPCell cell = new PdfPCell(new Phrase(text, font(FontFactory.HELVETICA_BOLD, 10, Color.WHITE)));
        styleTableCell(cell, headerColor);
        return cell;
    }

    private PdfPCell bodyCell(String text) {
        PdfPCell cell = new PdfPCell(new Phrase(text, font(FontFactory.HELVETICA, 10, Color.BLACK)));
        styleTableCell(cell, TABLE_BODY_COLOR);
        return cell;
    }

    private void styleTableCell(PdfPCell cell, Color backgroundColor) {
        cell.setHorizontalAlignment(Element.ALIGN_CENTER);
        cell.setVerticalAlignment(Element.ALIGN_MIDDLE);
        cell.setBackgroundColor(backgroundColor);
        cell.setBorderColor(TABLE_GRID_COLOR);
        cell.setBorderWidth(TABLE_GRID_WIDTH_POINTS);
        cell.setPadding(6);
    }

    private byte[] renderForecastChartPng(String city, List<ModelPrediction> forecastRows) throws Exception {
        JFreeChart chart = buildForecastChart(city, forecastRows);

        try (ByteArrayOutputStream pngBytes = new ByteArrayOutputStream()) {
            ChartUtils.writeChartAsPNG(pngBytes, chart, CHART_WIDTH_PIXELS, CHART_HEIGHT_PIXELS);
            return pngBytes.toByteArray();
        }
    }

    private JFreeChart buildForecastChart(String city, List<ModelPrediction> forecastRows) {
        XYSeries forecastSeries = createForecastLineSeries(forecastRows);
        XYSeries lowerBoundSeries = createLowerBoundSeries(forecastRows);
        XYSeries upperBoundSeries = createUpperBoundSeries(forecastRows);

        XYPlot plot = buildForecastPlot(forecastSeries, lowerBoundSeries, upperBoundSeries);

        return new JFreeChart(
                "Price Forecast — " + uppercaseFirstChar(city),
                JFreeChart.DEFAULT_TITLE_FONT,
                plot,
                true
        );
    }

    private XYPlot buildForecastPlot(XYSeries forecastSeries, XYSeries lowerBoundSeries, XYSeries upperBoundSeries) {
        XYSeriesCollection confidenceBandDataset = buildConfidenceBandDataset(lowerBoundSeries, upperBoundSeries);
        XYSeriesCollection forecastLineDataset = buildForecastLineDataset(forecastSeries);

        DateAxis dateAxis = new DateAxis("Date");
        NumberAxis predictedAxis = new NumberAxis("Predicted");

        XYDifferenceRenderer confidenceBandRenderer = buildConfidenceBandRenderer();
        XYLineAndShapeRenderer forecastLineRenderer = buildForecastLineRenderer();

        XYPlot plot = new XYPlot();
        plot.setDomainAxis(dateAxis);
        plot.setRangeAxis(predictedAxis);

        plot.setDataset(0, confidenceBandDataset);
        plot.setRenderer(0, confidenceBandRenderer);

        plot.setDataset(1, forecastLineDataset);
        plot.setRenderer(1, forecastLineRenderer);

        return plot;
    }

    private XYSeriesCollection buildConfidenceBandDataset(XYSeries lowerBoundSeries, XYSeries upperBoundSeries) {
        XYSeriesCollection dataset = new XYSeriesCollection();
        dataset.addSeries(upperBoundSeries);
        dataset.addSeries(lowerBoundSeries);
        return dataset;
    }

    private XYSeriesCollection buildForecastLineDataset(XYSeries forecastSeries) {
        XYSeriesCollection dataset = new XYSeriesCollection();
        dataset.addSeries(forecastSeries);
        return dataset;
    }

    private XYDifferenceRenderer buildConfidenceBandRenderer() {
        XYDifferenceRenderer renderer = new XYDifferenceRenderer(FORECAST_BAND_COLOR, FORECAST_BAND_COLOR, false);
        renderer.setSeriesPaint(0, FORECAST_BAND_COLOR);
        renderer.setSeriesPaint(1, FORECAST_BAND_COLOR);
        return renderer;
    }

    private XYLineAndShapeRenderer buildForecastLineRenderer() {
        XYLineAndShapeRenderer renderer = new XYLineAndShapeRenderer(true, false);
        renderer.setSeriesPaint(0, FORECAST_LINE_COLOR);
        return renderer;
    }

    private XYSeries createForecastLineSeries(List<ModelPrediction> forecastRows) {
        XYSeries series = createChronologicalSeries("Forecast");
        addForecastValues(series, forecastRows);
        return series;
    }

    private XYSeries createLowerBoundSeries(List<ModelPrediction> forecastRows) {
        XYSeries series = createChronologicalSeries("Lower");
        addLowerBoundValues(series, forecastRows);
        return series;
    }

    private XYSeries createUpperBoundSeries(List<ModelPrediction> forecastRows) {
        XYSeries series = createChronologicalSeries("Upper");
        addUpperBoundValues(series, forecastRows);
        return series;
    }

    private void addForecastValues(XYSeries series, List<ModelPrediction> forecastRows) {
        for (ModelPrediction prediction : forecastRows) {
            series.add(epochMillis(prediction.getPredictDate()), safe(prediction.getYhat()));
        }
    }

    private void addLowerBoundValues(XYSeries series, List<ModelPrediction> forecastRows) {
        for (ModelPrediction prediction : forecastRows) {
            double forecastValue = safe(prediction.getYhat());
            Double lowerValue = prediction.getYhatLower();
            series.add(epochMillis(prediction.getPredictDate()), lowerValue == null ? forecastValue : safe(lowerValue));
        }
    }

    private void addUpperBoundValues(XYSeries series, List<ModelPrediction> forecastRows) {
        for (ModelPrediction prediction : forecastRows) {
            double forecastValue = safe(prediction.getYhat());
            Double upperValue = prediction.getYhatUpper();
            series.add(epochMillis(prediction.getPredictDate()), upperValue == null ? forecastValue : safe(upperValue));
        }
    }

    private XYSeries createChronologicalSeries(String name) {
        boolean autoSort = true;
        boolean allowDuplicateXValues = true;
        return new XYSeries(name, autoSort, allowDuplicateXValues);
    }

    private long epochMillis(LocalDate date) {
        return date.atStartOfDay(ZoneOffset.UTC).toInstant().toEpochMilli();
    }

    private double safe(Double value) {
        return value == null ? 0.0 : value;
    }
}
